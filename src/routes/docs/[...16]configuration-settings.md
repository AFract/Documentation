---
title: Configuration Settings
description: A light-weight REST Api framework for ASP.Net 6 that implements REPR (Request-Endpoint-Response) Pattern.
---

# {$frontmatter.title}

## Customizing Functionality

There are several areas you can customize/override the default functionality of the library. All configuration settings must be specified during app startup with the **UseFastEndpoints()** call.

## Specify JSON Serializer Options

The settings for the default json serializer which is **System.Text.Json** can be set like so:

```cs
app.UseFastEndpoints(c =>
{
    c.Serializer.Options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
});
```

## Global Route Prefix

You can have a specified string automatically prepended to all route names in your app instead of repeating it in each and every route config method by specifying the prefix at app startup.

```cs |title=Program.cs
app.UseFastEndpoints(c =>
{
    c.Endpoints.RoutePrefix = "api";
});
```

For example, the following route config methods would result in the below endpoint routes:

```cs
Get("client/update"); -> "/api/client/update"
Put("inventory/delete"); -> "/api/inventory/delete"
Post("sales/recent-list"); -> "/api/sales/recent-list"
```

If needed, you can override or disable the global prefix from within individual endpoints like so:

```cs
public override void Configure()
{
    Post("user/create");
    RoutePrefixOverride("mobile");
}
```

In order to disable the global prefix, simply pass in a **string.Empty** to the **RoutePrefixOverride()** method.

## Filtering Endpoint Registration

If you'd like to prevent some of the endpoints in your project from being registered during startup, you have the option to supply a filtering function which will be run against each discovered endpoint.

If your function returns **true**, that particular endpoint will be registered. If the function returns **false** that endpoint will be ignored and not registered.

```cs
app.UseFastEndpoints(c =>
{
    c.Endpoints.Filter = ep =>
    {
        if (ep.Verbs.Contains("GET") && ep.Routes.Contains("/api/mobile/test"))
        {
            return false; // don't register this endpoint
        }
        return true;
    };
});
```

It is also possible to set a **Tag** for an endpoint and use that tag to filter out endpoints according to tags during registration as shown below:

```cs
public override void Configure()
{
    Get("client/update");
    Tags("Deprecated", "ToBeDeleted"); // has no relationship with Swagger tags
}

app.UseFastEndpoints(c =>
{
    c.Endpoints.Filter = ep =>
    {
        if (ep.EndpointTags?.Contains("Deprecated") is true)
        {
            return false; // don't register this endpoint
        }
        return true;
    };
});
```

## Global Endpoint Options

You can have a set of common settings applied to certain endpoints of your choice (or all of them) by specifying an action for the **Endpoints.Configurator** property.

The action you specify here will be executed for each endpoint during startup. You can inspect the **EndpointDefinition** argument to check what the current endpoint is and call most of the same methods you usually use from within the endpoint **Configure()** method as shown below.

```cs
app.UseFastEndpoints(c =>
{
    c.Endpoints.Configurator = ep =>
    {
        if (ep.Routes[0].StartsWith("/public") is true)
        {
            ep.AllowAnonymous();
            ep.Options(b => b.RequireHost("www.domain.com"));
            ep.Description(b => b.Produces<ErrorResponse>(400, "application/problem+json"));
        }
    };
});
```

:::admonition type=warning
Even though you can set most of the settings globally as above, calling the following methods globally will make the same calls at the endpoint level inside **Configure()** ineffective and are ignored.

- **RoutePrefixOverride() | Permissions() | PermissionsAll() | Claims() | ClaimsAll() | AuthSchemes() | Policies() | Roles()**


All other methods that are called inside **Configure()** will be effective and override what you do in the global configurator.
:::

## Customizing Error Responses

If the [default error response](https://api-ref.fast-endpoints.com/api/FastEndpoints.ErrorResponse.html) is not to your liking, you can specify a function to produce the exact error response you need. Whatever object you return from that function will be serialized to json and sent to the client whenever there needs to be a **400** error response sent downstream. The function will be supplied a list of validation failures, http context as well as a status code you can use to construct your own error response object like so:

```cs | title=Program.cs | copy
app.UseFastEndpoints(c =>
{
    c.Errors.ResponseBuilder = (failures, ctx, statusCode) =>
    {
        return new ValidationProblemDetails(
            failures.GroupBy(f => f.PropertyName)
                    .ToDictionary(
                        keySelector: e => e.Key,
                        elementSelector: e => e.Select(m => m.ErrorMessage).ToArray()))
        {
            Type = "https://tools.ietf.org/html/rfc7231#section-6.5.1",
            Title = "One or more validation errors occurred.",
            Status = statusCode,
            Instance = ctx.Request.Path,
            Extensions = { { "traceId", ctx.TraceIdentifier } }
        };
    };
});
```

## Custom De-Serialization Of JSON

If you'd like to take control of how request bodies are deserialized, simply provide a function like the following. Deserialize the object how ever you want and return it from the function. This function will be used to deserialize all incoming requests with a JSON body where applicable.

Input parameters:

```yaml
HttpRequest: the http request object
Type: the type of the request dto
JsonSerializerContext?: nullable json serializer context
CancellationToken: a cancellation token
```

```cs
app.UseFastEndpoints(c =>
{
    c.Serializer.RequestDeserializer = async (req, tDto, jCtx, ct) =>
    {
        using var reader = new StreamReader(req.Body);
        return Newtonsoft.Json.JsonConvert.DeserializeObject(await reader.ReadToEndAsync(), tDto);
    };
});
```

## Custom Response DTO Serialization 

The response serialization process can be overridden by specifying a function that returns a Task object.
You should set the content-type on the HTTP response object and write directly to the response body stream.
This function will be used to serialize all outgoing responses where a JSON body is required.
It is currently not possible to specify a serialization function per endpoint.

The parameters supplied to the function are as follows:

```yaml
HttpResponse: the http response object
object: the response dto to be serialized
string: the response content-type
JsonserializerContext?: nullable json serializer context
CancellationToken: a cancellation token
```

```cs
app.UseFastEndpoints(c =>
{
    c.Serializer.ResponseSerializer = (rsp, dto, cType, jCtx, ct) =>
    {
        rsp.ContentType = cType;
        return rsp.WriteAsync(Newtonsoft.Json.JsonConvert.SerializeObject(dto), ct);
    };
});
```

## Source Generator Based Startup

Reflection based assembly scanning is used by default to discover endpoints, validators, summaries and event handlers.

If your application has many hundreds of these types and it's running in a serverless environment, you may be able to get about a 20% startup speed boost by utilizing our experimental source generator.

To enable the source generator, simply install the **FastEndpoints.Generator** package from Nuget.

**Installation**

```cs |copy|title=terminal
dotnet add package FastEndpoints.Generator
```

**Usage**

```cs |title=Program.cs
builder.Services.AddFastEndpoints(o =>
{
    o.SourceGeneratorDiscoveredTypes = DiscoveredTypes.All;
});
```

If source generation is not working, make sure you have **.NET Compiler Platform SDK** installed in your environment. [see here](https://github.com/dj-nitehawk/FastEndpoints/issues/117#issuecomment-1136891324) for more info.
