---
title: Dependency Injection
description: FastEndpoints supports both property injection and constructor injection to make your life easier.
---

# {$frontmatter.title}

## Dependency Injection

There are three different ways to get access to services registered in the IOC container.
Consider the following service registration.

```cs |title=HelloWorldService.cs
public interface IHelloWorldService
{
    string SayHello();
}

public class HelloWorldService : IHelloWorldService
{
    public string SayHello() => "hello world!";
}
```

**IOC Registration**

```cs |title=Program.cs
builder.Services.AddScoped<IHelloWorldService, HelloWorldService>();
```

## Property Injection

Services can be automatically property injected by simply adding properties to the endpoint like so:

```cs |title=MyEndpoint.cs
public class MyEndpoint : EndpointWithoutRequest
{
    public IHelloWorldService HelloService { get; set; }

    public override void Configure()
    {
        Get("/api/hello-world");
    }

    public override async Task HandleAsync(CancellationToken ct)
    {
        await SendAsync(HelloService.SayHello());
    }
}
```

## Constructor Injection

Constructor injection is also supported. Just make sure not to assign the injected dependencies to public properties if using together with property injection.

```cs |title=MyEndpoint.cs
public class MyEndpoint : EndpointWithoutRequest
{
    private IHelloWorldService _helloService;

    public MyEndpoint(IHelloWorldService helloScv)
    {
        _helloService = helloScv;
    }

    public override void Configure()
    {
        Get("/api/hello-world");
    }

    public override async Task HandleAsync(CancellationToken ct)
    {
        await SendAsync(_helloService.SayHello());
    }
}

```

## Manual Resolving

Services can be resolved manually like so:

```cs
public override async Task HandleAsync(CancellationToken ct)
{
    IHelloWorldService? helloSvc = TryResolve<IHelloWorldService>();

    if (helloSvc is null)
        ThrowError("service not resolved!");

    var logger = Resolve<ILogger<MyEndpoint>>();

    logger.LogInformation("hello service is resolved...");

    await SendAsync(helloSvc.SayHello());
}
```

- **TryResolve()** - This method will try to resolve the given service. returns null if not resolved.

- **Resolve()** - This method will throw an exception if the requested service cannot be resolved.

## Pre-Resolved Services

The following services are pre-resolved and available for every endpoint handler with the following properties:

```
property: Config
service : IConfiguration

property: Env
service : IWebHostEnvironment

property: Logger
service : ILogger
```

They can be used in the endpoint handlers like so:

```cs
public override async Task HandleAsync(CancellationToken ct)
{
    Logger.LogInformation("this is a log message");
    var isProduction = Env.IsProduction();
    var smtpServer = Config["SMTP:HostName"];
}
```

## Validator Dependencies

Validators are registered in the DI container as singletons for [performance reasons](/benchmarks). Constructor injection as well as the above-mentioned **Resolve()** and **TryResolve()** methods are available for validators to get access to the dependencies. Take care not to maintain state in the validator due to it being singleton scope. If you need to resolve scoped dependencies in validators, you need to create a new scope and dispose it as shown below:

```cs title=MyValidator.cs
public class MyValidator : Validator<Request>
{
    public MyValidator(ISomeSingletonService singletonService)
    {
        var singletonSvc = singletonService; //from ctor injection
        var anotherSingletonService = Resolve<IAnotherSingletonService>(); //manual resolving

        //scoped dependency resolving
        using var scope = CreateScope();
        var scopedService = scope.Resolve<ISomeScopedService>();
    }
}
```
Most importantly don't forget the **using** keyword or manually dispose the **scope** at the end.

## Entity Mapper Dependencies

Just like validators, mappers are also singletons and you need to create a scope and dispose it if you need to resolve scoped dependencies.

```cs title=MyMapper.cs
public class MyMapper : Mapper<Request, Response, Person>
{
    public MyMapper(ISomeSingletonService singletonService)
    {
        var singletonSvc = singletonService; //from ctor injection
        var anotherSingletonService = Resolve<IAnotherSingletonService>(); //manual resolving

        //scoped dependency resolving
        using var scope = CreateScope();
        var scopedService = scope.Resolve<ISomeScopedService>();
    }
}
```

## Event Handler Dependencies

Event handlers are also singletons just like validators and mappers with the exception that they don't support constructor injection. To resolve singleton dependencies you can use the **Resolve()** and **TryResolve()** and you must create and dispose a scope if you need to access scoped dependencies like so:

```cs title=MyEventHandler.cs
public class MyEventHandler : FastEventHandler<MyEvent>
{
    public override Task HandleAsync(MyEvent eventModel, CancellationToken ct)
    {
        //manual resolving
        var singletonService = Resolve<ISomeSingletonService>();

        //scoped dependency resolving
        using var scope = CreateScope();
        var scopedService = scope.Resolve<ISomeScopedService>();
    }
}
```