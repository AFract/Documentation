import{S as Ht,i as Pt,s as Lt,l as p,r as l,a as c,w as z,m as f,n as u,u as r,h as t,c as d,x as M,p as _,b as a,M as s,y as j,v as Rt,f as J,t as K,B as Q,_ as Dt}from"../../chunks/index-6391be64.js";import{f as St}from"../../chunks/scroll-4f99ad69.js";import{C as Nt}from"../../chunks/CodeFence-e0140bb4.js";import{L as me}from"../../chunks/Link-69c668c2.js";import"../../chunks/singletons-9fd4729a.js";import"../../chunks/contexts-c56b72f8.js";function Gt(h){let i;return{c(){i=l("#")},l(o){i=r(o,"#")},m(o,m){a(o,i,m)},d(o){o&&t(i)}}}function Ot(h){let i;return{c(){i=l("#")},l(o){i=r(o,"#")},m(o,m){a(o,i,m)},d(o){o&&t(i)}}}function Xt(h){let i;return{c(){i=l("#")},l(o){i=r(o,"#")},m(o,m){a(o,i,m)},d(o){o&&t(i)}}}function Ut(h){let i;return{c(){i=l("#")},l(o){i=r(o,"#")},m(o,m){a(o,i,m)},d(o){o&&t(i)}}}function Wt(h){let i;return{c(){i=l("#")},l(o){i=r(o,"#")},m(o,m){a(o,i,m)},d(o){o&&t(i)}}}function zt(h){let i,o=h[0].title+"",m,R,B,F,He,he,D,Pe,ye,P,b,q,Le,$e,S,Re,_e,A,De,V,Se,Ne,Be,N,Ge,be,v,C,Oe,ve,G,Xe,we,g,Ue,Y,We,ze,Ee,x,Me,Z,je,Je,Fe,I,Ke,ee,Qe,Ve,qe,w,T,Ye,Ae,$,Ze,te,et,tt,ne,nt,st,Ce,O,at,ge,E,k,ot,xe,y,se,ae,lt,rt,oe,le,it,pt,re,ie,ft,ut,pe,fe,ct,ue;return F=new me({props:{class:"header-anchor",href:"#endpoint-rate-limiting","aria-hidden":"true",$$slots:{default:[Gt]},$$scope:{ctx:h}}}),P=new Nt({props:{lang:"csharp",ext:"cs",linesCount:10,code:`<pre><code><span class="line"><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">override</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Configure</span><span style="color: #ABB2BF">()</span></span>
<span class="line"><span style="color: #ABB2BF">{</span></span>
<span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">Post</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;/order/create&quot;</span><span style="color: #ABB2BF">);</span></span>
<span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">Throttle</span><span style="color: #ABB2BF">(</span></span>
<span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">hitLimit</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">120</span><span style="color: #ABB2BF">,</span></span>
<span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">durationSeconds</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF">,</span></span>
<span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">headerName</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">&quot;X-Client-Id&quot;</span></span>
<span class="line"><span style="color: #ABB2BF">    ); </span><span style="color: #7F848E; font-style: italic">// this is optional</span></span>
<span class="line"><span style="color: #ABB2BF">}</span></span>
<span class="line"></span></code></pre>`}}),q=new me({props:{class:"header-anchor",href:"#hit-limit-window-duration","aria-hidden":"true",$$slots:{default:[Ot]},$$scope:{ctx:h}}}),C=new me({props:{class:"header-anchor",href:"#header-name","aria-hidden":"true",$$slots:{default:[Xt]},$$scope:{ctx:h}}}),T=new me({props:{class:"header-anchor",href:"#header-reliability","aria-hidden":"true",$$slots:{default:[Ut]},$$scope:{ctx:h}}}),k=new me({props:{class:"header-anchor",href:"#limitations-warnings","aria-hidden":"true",$$slots:{default:[Wt]},$$scope:{ctx:h}}}),{c(){i=p("h1"),m=l(o),R=c(),B=p("h2"),z(F.$$.fragment),He=l(" Endpoint Rate Limiting"),he=c(),D=p("p"),Pe=l("It is possible to rate limit individual endpoints based on the presence of an HTTP header in the incoming request like below:"),ye=c(),z(P.$$.fragment),b=p("h2"),z(q.$$.fragment),Le=l(" Hit Limit & Window Duration"),$e=c(),S=p("p"),Re=l("The above for example will only allow 120 requests from each unique client (identified by the header value) within a 60 second window."),_e=c(),A=p("p"),De=l("If 121 requests are made by a client within 60 seconds, a "),V=p("strong"),Se=l("429 too many requests"),Ne=l(" response will be automatically sent for the 121st request."),Be=c(),N=p("p"),Ge=l("The counter is reset every 60 seconds and the client is able to make another 120 requests in the next 60 seconds, and so on."),be=c(),v=p("h2"),z(C.$$.fragment),Oe=l(" Header Name"),ve=c(),G=p("p"),Xe=l("The header name can be set to anything you prefer."),we=c(),g=p("p"),Ue=l("If it's not specified, the library will try to read the value of "),Y=p("strong"),We=l("X-Forwarded-For"),ze=l(" header from the incoming request."),Ee=c(),x=p("p"),Me=l("If that's unsuccessful, it will try to read the "),Z=p("strong"),je=l("HttpContext.Connection.RemoteIpAddress"),Je=l(" in order to uniquely identify the client making the request."),Fe=c(),I=p("p"),Ke=l("If all attempts are unsuccessful, a "),ee=p("strong"),Qe=l("403 Forbidden"),Ve=l(" response will be sent."),qe=c(),w=p("h2"),z(T.$$.fragment),Ye=l(" Header Reliability"),Ae=c(),$=p("p"),Ze=l("Both "),te=p("strong"),et=l("X-Forwarded-For"),tt=l(" and "),ne=p("strong"),nt=l("HttpContext.Connection.RemoteIpAddress"),st=l(" could be unreliable for uniquely identifying clients if they are behind a NAT, reverse proxy, or anonymizing vpn/proxy etc."),Ce=c(),O=p("p"),at=l("Therefore, the recommended strategy is to generate a unique identifier such as a GUID in your client application and use that as the header value in each request for the entirety of the session/app cycle."),ge=c(),E=p("h2"),z(k.$$.fragment),ot=l(" Limitations & Warnings"),xe=c(),y=p("ul"),se=p("li"),ae=p("p"),lt=l("Should not be used for security or ddos protection. a malicious client can easily set a unique header value per request in order to circumvent the throttling."),rt=c(),oe=p("li"),le=p("p"),it=l("Should be aware of the slight performance degradation due to resource allocation and amount of work being done."),pt=c(),re=p("li"),ie=p("p"),ft=l("Only per endpoint limits can be set. no global limits can be enforced. this won't ever be added due to performance reasons."),ut=c(),pe=p("li"),fe=p("p"),ct=l("Consider a rate limiting solution that is out of process at the gateway level for better performance/security."),this.h()},l(e){i=f(e,"H1",{});var n=u(i);m=r(n,o),n.forEach(t),R=d(e),B=f(e,"H2",{id:!0,tabindex:!0});var X=u(B);M(F.$$.fragment,X),He=r(X," Endpoint Rate Limiting"),X.forEach(t),he=d(e),D=f(e,"P",{});var ce=u(D);Pe=r(ce,"It is possible to rate limit individual endpoints based on the presence of an HTTP header in the incoming request like below:"),ce.forEach(t),ye=d(e),M(P.$$.fragment,e),b=f(e,"H2",{id:!0,tabindex:!0});var U=u(b);M(q.$$.fragment,U),Le=r(U," Hit Limit & Window Duration"),U.forEach(t),$e=d(e),S=f(e,"P",{});var de=u(S);Re=r(de,"The above for example will only allow 120 requests from each unique client (identified by the header value) within a 60 second window."),de.forEach(t),_e=d(e),A=f(e,"P",{});var L=u(A);De=r(L,"If 121 requests are made by a client within 60 seconds, a "),V=f(L,"STRONG",{});var yt=u(V);Se=r(yt,"429 too many requests"),yt.forEach(t),Ne=r(L," response will be automatically sent for the 121st request."),L.forEach(t),Be=d(e),N=f(e,"P",{});var $t=u(N);Ge=r($t,"The counter is reset every 60 seconds and the client is able to make another 120 requests in the next 60 seconds, and so on."),$t.forEach(t),be=d(e),v=f(e,"H2",{id:!0,tabindex:!0});var dt=u(v);M(C.$$.fragment,dt),Oe=r(dt," Header Name"),dt.forEach(t),ve=d(e),G=f(e,"P",{});var _t=u(G);Xe=r(_t,"The header name can be set to anything you prefer."),_t.forEach(t),we=d(e),g=f(e,"P",{});var Ie=u(g);Ue=r(Ie,"If it's not specified, the library will try to read the value of "),Y=f(Ie,"STRONG",{});var Bt=u(Y);We=r(Bt,"X-Forwarded-For"),Bt.forEach(t),ze=r(Ie," header from the incoming request."),Ie.forEach(t),Ee=d(e),x=f(e,"P",{});var Te=u(x);Me=r(Te,"If that's unsuccessful, it will try to read the "),Z=f(Te,"STRONG",{});var bt=u(Z);je=r(bt,"HttpContext.Connection.RemoteIpAddress"),bt.forEach(t),Je=r(Te," in order to uniquely identify the client making the request."),Te.forEach(t),Fe=d(e),I=f(e,"P",{});var ke=u(I);Ke=r(ke,"If all attempts are unsuccessful, a "),ee=f(ke,"STRONG",{});var vt=u(ee);Qe=r(vt,"403 Forbidden"),vt.forEach(t),Ve=r(ke," response will be sent."),ke.forEach(t),qe=d(e),w=f(e,"H2",{id:!0,tabindex:!0});var mt=u(w);M(T.$$.fragment,mt),Ye=r(mt," Header Reliability"),mt.forEach(t),Ae=d(e),$=f(e,"P",{});var W=u($);Ze=r(W,"Both "),te=f(W,"STRONG",{});var wt=u(te);et=r(wt,"X-Forwarded-For"),wt.forEach(t),tt=r(W," and "),ne=f(W,"STRONG",{});var Et=u(ne);nt=r(Et,"HttpContext.Connection.RemoteIpAddress"),Et.forEach(t),st=r(W," could be unreliable for uniquely identifying clients if they are behind a NAT, reverse proxy, or anonymizing vpn/proxy etc."),W.forEach(t),Ce=d(e),O=f(e,"P",{});var Ft=u(O);at=r(Ft,"Therefore, the recommended strategy is to generate a unique identifier such as a GUID in your client application and use that as the header value in each request for the entirety of the session/app cycle."),Ft.forEach(t),ge=d(e),E=f(e,"H2",{id:!0,tabindex:!0});var ht=u(E);M(k.$$.fragment,ht),ot=r(ht," Limitations & Warnings"),ht.forEach(t),xe=d(e),y=f(e,"UL",{});var H=u(y);se=f(H,"LI",{});var qt=u(se);ae=f(qt,"P",{});var At=u(ae);lt=r(At,"Should not be used for security or ddos protection. a malicious client can easily set a unique header value per request in order to circumvent the throttling."),At.forEach(t),qt.forEach(t),rt=d(H),oe=f(H,"LI",{});var Ct=u(oe);le=f(Ct,"P",{});var gt=u(le);it=r(gt,"Should be aware of the slight performance degradation due to resource allocation and amount of work being done."),gt.forEach(t),Ct.forEach(t),pt=d(H),re=f(H,"LI",{});var xt=u(re);ie=f(xt,"P",{});var It=u(ie);ft=r(It,"Only per endpoint limits can be set. no global limits can be enforced. this won't ever be added due to performance reasons."),It.forEach(t),xt.forEach(t),ut=d(H),pe=f(H,"LI",{});var Tt=u(pe);fe=f(Tt,"P",{});var kt=u(fe);ct=r(kt,"Consider a rate limiting solution that is out of process at the gateway level for better performance/security."),kt.forEach(t),Tt.forEach(t),H.forEach(t),this.h()},h(){_(B,"id","endpoint-rate-limiting"),_(B,"tabindex","-1"),_(b,"id","hit-limit-window-duration"),_(b,"tabindex","-1"),_(v,"id","header-name"),_(v,"tabindex","-1"),_(w,"id","header-reliability"),_(w,"tabindex","-1"),_(E,"id","limitations-warnings"),_(E,"tabindex","-1")},m(e,n){a(e,i,n),s(i,m),a(e,R,n),a(e,B,n),j(F,B,null),s(B,He),a(e,he,n),a(e,D,n),s(D,Pe),a(e,ye,n),j(P,e,n),a(e,b,n),j(q,b,null),s(b,Le),a(e,$e,n),a(e,S,n),s(S,Re),a(e,_e,n),a(e,A,n),s(A,De),s(A,V),s(V,Se),s(A,Ne),a(e,Be,n),a(e,N,n),s(N,Ge),a(e,be,n),a(e,v,n),j(C,v,null),s(v,Oe),a(e,ve,n),a(e,G,n),s(G,Xe),a(e,we,n),a(e,g,n),s(g,Ue),s(g,Y),s(Y,We),s(g,ze),a(e,Ee,n),a(e,x,n),s(x,Me),s(x,Z),s(Z,je),s(x,Je),a(e,Fe,n),a(e,I,n),s(I,Ke),s(I,ee),s(ee,Qe),s(I,Ve),a(e,qe,n),a(e,w,n),j(T,w,null),s(w,Ye),a(e,Ae,n),a(e,$,n),s($,Ze),s($,te),s(te,et),s($,tt),s($,ne),s(ne,nt),s($,st),a(e,Ce,n),a(e,O,n),s(O,at),a(e,ge,n),a(e,E,n),j(k,E,null),s(E,ot),a(e,xe,n),a(e,y,n),s(y,se),s(se,ae),s(ae,lt),s(y,rt),s(y,oe),s(oe,le),s(le,it),s(y,pt),s(y,re),s(re,ie),s(ie,ft),s(y,ut),s(y,pe),s(pe,fe),s(fe,ct),ue=!0},p(e,[n]){(!ue||n&1)&&o!==(o=e[0].title+"")&&Rt(m,o);const X={};n&2&&(X.$$scope={dirty:n,ctx:e}),F.$set(X);const ce={};n&2&&(ce.$$scope={dirty:n,ctx:e}),q.$set(ce);const U={};n&2&&(U.$$scope={dirty:n,ctx:e}),C.$set(U);const de={};n&2&&(de.$$scope={dirty:n,ctx:e}),T.$set(de);const L={};n&2&&(L.$$scope={dirty:n,ctx:e}),k.$set(L)},i(e){ue||(J(F.$$.fragment,e),J(P.$$.fragment,e),J(q.$$.fragment,e),J(C.$$.fragment,e),J(T.$$.fragment,e),J(k.$$.fragment,e),ue=!0)},o(e){K(F.$$.fragment,e),K(P.$$.fragment,e),K(q.$$.fragment,e),K(C.$$.fragment,e),K(T.$$.fragment,e),K(k.$$.fragment,e),ue=!1},d(e){e&&t(i),e&&t(R),e&&t(B),Q(F),e&&t(he),e&&t(D),e&&t(ye),Q(P,e),e&&t(b),Q(q),e&&t($e),e&&t(S),e&&t(_e),e&&t(A),e&&t(Be),e&&t(N),e&&t(be),e&&t(v),Q(C),e&&t(ve),e&&t(G),e&&t(we),e&&t(g),e&&t(Ee),e&&t(x),e&&t(Fe),e&&t(I),e&&t(qe),e&&t(w),Q(T),e&&t(Ae),e&&t($),e&&t(Ce),e&&t(O),e&&t(ge),e&&t(E),Q(k),e&&t(xe),e&&t(y)}}}function Mt(h,i,o){let m;return Dt(h,St,R=>o(0,m=R)),[m]}class Zt extends Ht{constructor(i){super(),Pt(this,i,Mt,zt,Lt,{})}}export{Zt as default};
